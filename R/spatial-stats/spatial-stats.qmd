---
title: "Spatial Statistics (R)"
format: html
editor: visual
execute: 
  echo: true
  warning: false
---

# Types of spatial data:

## a) aerial (lattice):

no. of events aggregated in an area e.g admin units

```{r}
#| include: true
# browseURL("https://www.paulamoraga.com/book-spatial/types-of-spatial-data.html")
ipk <- function(pkg) {
  for (i in seq_len(length(pkg))) {
    if (!require(pkg[i], character.only = TRUE))
      install.packages(pkg[i], dependencies = TRUE,
                       repos = "http://cran.rstudio.com")
    
  }
  require(pkg[i], character.only = TRUE)
}
pks <- c(
  "sf",
  "sp",
  "mapview",
  "terra",
  "spData",
  "ggplot2",
  "malariaAtlas",
  "sparr",
  "rnaturalearth",
  "geodata",
  "tmap",
  "leaflet",
  "flowmapblue",
  "viridis",
  "plotly",
  "htmlwidgets",
  "webshot",
  "RColorBrewer",
  "leaflet.extras2",
  "maps",
  "raster",
  "spdep",
  "usethis"
)
# ddpcr::quiet(ipk(pks))
suppressPackageStartupMessages(ipk(pks))
# devtools::install_github("FlowmapBlue/flowmapblue.R")
```

```{r}
#| label: fig-deaths
#| fig-cap: Example of areal data. Number of sudden infant deaths in counties of North Carolina, USA, in 1974.
#| 
d <- st_read(system.file("shape/nc.shp", package = "sf"), quiet = TRUE)
mapview(d, zcol = "SID74")
```

Using ggplot

```{r}
#| label: fig-income
#| fig-cap: Example of areal data. Household income in $1000 USD in neighborhoods in Columbus, Ohio, in 1980.
d <- st_read(system.file("shapes/columbus.shp", package = "spData"), quiet = TRUE)
ggplot(d) + geom_sf(aes(fill = INC))
```

```{r}
#| label: luxe
#| fig-cap: Example of areal data. Elevation at raster grid cells covering Luxembourg.

d <- rast(system.file("ex/elev.tif", package = "terra"))
plot(d)
```

## b) Geostatistical data

```{r}
#| label: fig-soil
#| fig-cap:  Example of geostatistical data. Topsoil lead concentrations at locations sampled in a flood plain of the river Meuse, The Netherlands.

data("meuse")
meuse <- st_as_sf(meuse, coords = c("x", "y"), crs = 2892)
mapview(meuse, zcol = "lead", map.type = "CartoDB.Voyager")
```

```{r}
#| label: fig-price
#| fig-cap:  Example of geostatistical data. Price per square meter of a set of apartments in Athens, Greece, in 2017.
mapview(properties, zcol = "prpsqm")
```

```{r}
#| label: fig-mal
#| message: false
#| fig-cap:  Example of geostatistical data. Malaria prevalence at specific locations in Kenya.

d <- getPR(country = "Kenya", species = "both")
autoplot(d)
```

## c) point patterns

```{r}
#| label: fig-case
#| fig-cap: Example of point pattern. Locations of cases and controls of primary biliary cirrhosis in north-eastern England between 1987 and 1994.

data(pbc)
plot(unmark(pbc[which(pbc$marks == "case"), ]), main = "cases")
axis(1)
axis(2)
title(xlab = "Easting", ylab = "Northing")
plot(unmark(pbc[which(pbc$marks == "control"), ]),
     pch = 3, main = "controls")
axis(1)
axis(2)
title(xlab = "Easting", ylab = "Northing")
```

# {sf}

## Creating sf object

-   use `sf_st()` to create an sf object by providing two elements; a df and simple feature geometry list-column **sfc** containing simple feature geometries **sfg**
-   first create simple feauture geometries **sfg** and use the `st_sf()` to put the df and with the attributes and simple feature geometry list-column **sfc** together
-   simple feature geometries **sfg** can be of single point - `st_point()`, multipoint - `st_multipoint()` and polygon - `st_polygon()`

```{r}
# single point
p1_sfg <- st_point(c(2, 2))
p2_sfg <- st_point(c(2.5, 3))

# set of points
p <- rbind(c(6, 2), c(6.1, 2.6), c(6.8, 2.5),
           c(6.2, 1.5), c(6.8, 1.8))
mp_sfg <- st_multipoint(p)

# polygon
p1 <- rbind(c(10, 0), c(11, 0), c(13, 2),
            c(12, 4), c(11, 4), c(10, 0))
p2 <- rbind(c(11, 1), c(11, 2), c(12, 2), c(11, 1))
pol_sfg <- st_polygon(list(p1, p2))

# create sf object
p_sfc <- st_sfc(p1_sfg, p2_sfg, mp_sfg, pol_sfg)
df <- data.frame(V1 = c("A", "B", "C", "D"))
p_sf <- st_sf(df, geometry = p_sfc)
# plot
ggplot(p_sf) + geom_sf(aes(col = V1), size = 3) + theme_bw()
```

# Making maps with R

```{r}
nameshp <- system.file("shape/nc.shp", package = "sf")
d <- st_read(nameshp, quiet = T)
d$vble <- d$SID74
d$vble2 <- d$SID79
```

## **ggplot2**

```{r}
ggplot(d) + geom_sf(aes(fill = vble)) +
  scale_fill_viridis() + theme_bw()
```

-   make it interactive with `{plotly}`

```{r}
g <- ggplot(d) + geom_sf(aes(fill = vble))
ggplotly(g)
```

## **leaflet**

-   the **sf** object that we pass to `leaflet()` needs to have a geographic coordinate reference system (CRS) indicating latitude and longitude (EPSG code 4326)
-   we use the `st_transform()` function of **sf** to transform the data d which has CRS given by EPSG code 4267 to CRS with EPSG code 4326

```{r}
# set CRS
st_crs(d)$epsg # retrieve CRS
d <- st_transform(d, 4326)
```

```{r}
# create a color palette
pal <- colorNumeric(palette = "YlOrRd", domain = d$vble)
l <- leaflet(d) |> addTiles() |>
  addPolygons(color = "white", fillColor = ~ pal(vble), fillOpacity = 0.8) |>
  addLegend(pal = pal, values = ~vble, opacity = 0.8)
l
```

Note that the default background map added with `addTiles()` can be changed by another map with `addProviderTiles()` specifying another tile layer. Examples of tile layers can be seen at the leaflet providersâ€™ [website](https://leaflet-extras.github.io/leaflet-providers/preview/index.html). We can also use the `addMiniMap()` function to add an inset map

```{r}
l |> addMiniMap()
```

-   saving leaflet maps is through `saveWidget()` of **htmlwidgets**. You then take a screenshot using **webshot**

```{r}
# Saves map.html
# library(htmlwidgets)
saveWidget(widget = l, file = "map.html")

# Takes a screenshot of the map.html created
# and saves it as map.png
# library(webshot)
# webshot::install_phantomjs()
webshot(url = "map.html", file = "map.png")
```

## **mapview**

```{r}
pal <- colorRampPalette(brewer.pal(9, "YlOrRd"))
mapview(
  d,
  zcol = "vble",
  map.types = "CartoDB.DarkMatter",
  col.regions = pal,
  layer.name = "SDI"
)

```

An inset map can also be added by using the `addMiniMap()` function of **leaflet**.

```{r}
map1 <- mapview(d, zcol = "vble")
leaflet::addMiniMap(map1@map)
```

## side by side plots with **mapview**

```{r}
# library(leaflet.extras2)
# library(RColorBrewer)
pal <- colorRampPalette(brewer.pal(9, "YlOrRd"))

# common legend
at <- seq(min(c(d$vble, d$vble2)), max(c(d$vble, d$vble2)),
          length.out = 8)

m1 <- mapview(d, zcol = "vble", map.types = "CartoDB.Positron",
              col.regions = pal, at = at)
m2 <- mapview(d, zcol = "vble2", map.types = "CartoDB.Positron",
              col.regions = pal, at = at)

m1 | m2
```

## Synchronized maps with **leafsync**

```{r}
library(RColorBrewer)
pal <- colorRampPalette(brewer.pal(9, "YlOrRd"))

# common legend
at <- seq(min(c(d$vble, d$vble2)), max(c(d$vble, d$vble2)),
          length.out = 8)

m1 <- mapview(d, zcol = "vble", map.types = "CartoDB.Positron",
              col.regions = pal, at = at)
m2 <- mapview(d, zcol = "vble2", map.types = "CartoDB.Positron",
              col.regions = pal, at = at)
m <- leafsync::sync(m1, m2)
m
```

## **tmap**

```{r}
library(tmap)
tmap_mode("plot")
tm_shape(d) + tm_polygons("vble")
```

## maps of point data

```{r}
d <- world.cities
# select South Africa
d <- d[which(d$country.etc == "South Africa"),]
# Transform to sf object
d <- st_as_sf(d, coords = c("long", "lat"))
# Assign CRS
st_crs(d) <- 4326

d$vble <- d$pop
d$size <- sqrt(d$vble)/100
```

```{r}
ggplot(d) + geom_sf(aes(col = vble, size = size)) +
  scale_color_viridis()
```

A leaflet map can be created using `addCircles()` specifying the radius and color of the point

```{r}
pal <- colorNumeric(palette = "viridis", domain = d$vble)
leaflet(d) %>% addTiles() %>%
  addCircles(lng = st_coordinates(d)[, 1],
             lat = st_coordinates(d)[, 2],
             radius = ~sqrt(vble)*10,
             color = ~pal(vble), popup = ~name) %>%
  addLegend(pal = pal, values = ~vble, position = "bottomright")
```

-   with **mapview**:

```{r}
d$size <- sqrt(d$vble)
mapview(d, zcol = "vble", cex = "size")

tmap_mode("view")
tm_shape(d) + tm_dots("vble", scale = sqrt(d$vble)/500,
                      palette = "viridis")
```

## maps of raster data

```{r}
# library(terra)
filename <- system.file("ex/elev.tif", package = "terra")
r <- rast(filename)

# Transform data to sf object
d <- st_as_sf(as.data.frame(r, xy = TRUE), coords = c("x", "y"))
# Assign CRS
st_crs(d) <- 4326
# Plot
ggplot(d) + geom_sf() +
  geom_raster(data = as.data.frame(r, xy = TRUE),
              aes(x = x, y = y, fill = elevation))
```

To use the **leaflet** and **mapview** packages, we transform the data from class `terra` to `RasterLayer` with the `raster::brick()`

```{r}
library(raster)
rb <- raster::brick(r)

pal <- colorNumeric("YlOrRd", values(r),
                    na.color = "transparent")
leaflet() %>% addTiles() %>%
  addRasterImage(rb, colors = pal, opacity = 0.8) %>%
  addLegend(pal = pal, values = values(r), title = "elevation")
```

# Spatial neighborhood matrices

-   **spdep** package

## Neighbors based on contiguity

`poly2nb()` can be used to construct a list of neighbors based on areas with contiguous boundaries,

```{r}
map <- st_read(system.file("shapes/columbus.shp", package = "spData"), quiet = TRUE)
nb <- spdep::poly2nb(map, queen = TRUE)
head(nb)
```

```{r}
plot(st_geometry(map), border = "lightgray")
plot.nb(nb, st_geometry(map), add = TRUE)
```

We can plot the neighbors of a given area by adding a new column in map representing the neighbors of the area. For example, Figure below shows the neighbors of area 20

```{r}
id <- 20
map$neighbors <- "other"
map$neighbors[id] <- "area"
map$neighbors[nb[[id]]] <- "neighbors"
ggplot(map) + geom_sf(aes(fill = neighbors)) + theme_bw() +
  scale_fill_manual(values = c("gray30","gray", "white"))
```

Given a neighbor list, the cardinality function `spdep::card()` counts the number of neighbors of each area. We can also obtain the number of neighbors of each area with `lengths(nb)`. Then, we can use `table(1:nrow(map), card(nb))` to build a table with the areas' ids in rows, and the number of neighbors in columns

## Neighbors based on k nearest neighbors

The function `knearneigh()` of **spdep** allows us to obtain a matrix with the indices of points belonging to the set of the k nearest neighbors of each area

```{r}
# 3 nearest neighbors
coo <- st_centroid(map)
nb <- knn2nb(knearneigh(coo, k = 3))
plot(st_geometry(map), border = "lightgray")
plot.nb(nb, st_geometry(map), add = TRUE)
```

## Neighbors based on distance

The `dnearneigh()` function of **spdep** builds a list of neighbors based on a distance between specific lower and upper bounds.

```{r}
# neighbors based on distance
# Neighbors based on distance
nb <- dnearneigh(x = st_centroid(map), d1 = 0, d2 = 0.4)
plot(st_geometry(map), border = "lightgray")
plot.nb(nb, st_geometry(map), add = TRUE)
```

# Spatial autocorrelation

Using Moran's I index

## Global Moran's I

The function `moran.test()` of the **spdep** package can be used to test spatial autocorrelation using Moran's I

```{r}
# Neighbors
map <- st_read(system.file("shapes/boston_tracts.shp",
                           package = "spData"), quiet = TRUE)
map$vble <- map$MEDV
nb <- poly2nb(map, queen = T) # queen shares point or border
nbw <- nb2listw(nb, style = "W")
# Global Moran's I
gmoran <- moran.test(map$vble, nbw, alternative = "greater")
gmoran
```

Monte Carlo approach using `moran.mc()`

```{r}
gmoranMC <- moran.mc(map$vble, nbw, nsim = 999)
gmoranMC
```

```{r}
hist(gmoranMC$res)
abline(v = gmoranMC$statistic, col = "red")
```

Moran's I scatterplot

```{r}
moran.plot(map$vble, nbw)
```

## Local Moran's I

```{r}
lmoran <- localmoran(map$vble, nbw, alternative = "greater")
head(lmoran)
```

Map of housing prices and local Moran's I

```{r}
tmap_mode("view")
map$lmI <- lmoran[, "Ii"] # local Moran's I
map$lmZ <- lmoran[, "Z.Ii"] # z-scores
# p-values corresponding to alternative greater
map$lmp <- lmoran[, "Pr(z > E(Ii))"]

p1 <- tm_shape(map) +
  tm_polygons(col = "vble", title = "vble", style = "quantile") +
  tm_layout(legend.outside = TRUE)

p2 <- tm_shape(map) +
  tm_polygons(col = "lmI", title = "Local Moran's I",
              style = "quantile") +
  tm_layout(legend.outside = TRUE)

p3 <- tm_shape(map) +
  tm_polygons(col = "lmZ", title = "Z-score",
              breaks = c(-Inf, 1.65, Inf)) +
  tm_layout(legend.outside = TRUE)

p4 <- tm_shape(map) +
  tm_polygons(col = "lmp", title = "p-value",
              breaks = c(-Inf, 0.05, Inf)) +
  tm_layout(legend.outside = TRUE)

tmap_arrange(p1, p2, p3, p4) 
```

```{r}
tm_shape(map) + tm_polygons(col = "lmZ",
title = "Local Moran's I", style = "fixed",
breaks = c(-Inf, -1.96, 1.96, Inf),
labels = c("Negative SAC", "No SAC", "Positive SAC"),
palette =  c("blue", "white", "red")) +
tm_layout(legend.outside = TRUE)
```

## Clusters

Local Moran's I allows us to identify clusters of the following types:

-   High-High: areas of high values with neighbors of high values,
-   High-Low: areas of high values with neighbors of low values,
-   Low-High: areas of low values with neighbors of high values,
-   Low-Low: areas of low values with neighbors of low values.

```{r}
lmoran <- localmoran(map$vble, nbw, alternative = "two.sided")
head(lmoran)
```

```{r}
mp <- moran.plot(as.vector(scale(map$vble)), nbw)
```

```{r}
map$quadrant <- NA
# high-high
map[(mp$x >= 0 & mp$wx >= 0) & (map$lmp <= 0.05), "quadrant"]<- 1
# low-low
map[(mp$x <= 0 & mp$wx <= 0) & (map$lmp <= 0.05), "quadrant"]<- 2
# high-low
map[(mp$x >= 0 & mp$wx <= 0) & (map$lmp <= 0.05), "quadrant"]<- 3
# low-high
map[(mp$x <= 0 & mp$wx >= 0) & (map$lmp <= 0.05), "quadrant"]<- 4
# non-significant
map[(map$lmp > 0.05), "quadrant"] <- 5
```

We create the variable quadrant denoting the type of cluster for each of the areas using the quadrant corresponding to its value and its spatially lagged value, and the p-value

```{r}
tm_shape(map) + tm_fill(col = "quadrant", title = "",
breaks = c(1, 2, 3, 4, 5, 6),
palette =  c("red", "blue", "lightpink", "skyblue2", "white"),
labels = c("High-High", "Low-Low", "High-Low",
           "Low-High", "Non-significant")) +
tm_legend(text.size = 1)  + tm_borders(alpha = 0.5) +
tm_layout(frame = FALSE,  title = "Clusters")  +
tm_layout(legend.outside = TRUE)
```
